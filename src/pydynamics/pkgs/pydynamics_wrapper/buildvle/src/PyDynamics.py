# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_PyDynamics', [dirname(__file__)])
        except ImportError:
            import _PyDynamics
            return _PyDynamics
        if fp is not None:
            try:
                _mod = imp.load_module('_PyDynamics', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _PyDynamics = swig_import_helper()
    del swig_import_helper
else:
    import _PyDynamics
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _PyDynamics.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _PyDynamics.SwigPyIterator_value(self)
    def incr(self, n = 1): return _PyDynamics.SwigPyIterator_incr(self, n)
    def decr(self, n = 1): return _PyDynamics.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _PyDynamics.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _PyDynamics.SwigPyIterator_equal(self, *args)
    def copy(self): return _PyDynamics.SwigPyIterator_copy(self)
    def next(self): return _PyDynamics.SwigPyIterator_next(self)
    def __next__(self): return _PyDynamics.SwigPyIterator___next__(self)
    def previous(self): return _PyDynamics.SwigPyIterator_previous(self)
    def advance(self, *args): return _PyDynamics.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _PyDynamics.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _PyDynamics.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _PyDynamics.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _PyDynamics.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _PyDynamics.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _PyDynamics.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _PyDynamics.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class ExternalEventList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExternalEventList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExternalEventList, name)
    __repr__ = _swig_repr
    def iterator(self): return _PyDynamics.ExternalEventList_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _PyDynamics.ExternalEventList___nonzero__(self)
    def __bool__(self): return _PyDynamics.ExternalEventList___bool__(self)
    def __len__(self): return _PyDynamics.ExternalEventList___len__(self)
    def pop(self): return _PyDynamics.ExternalEventList_pop(self)
    def __getslice__(self, *args): return _PyDynamics.ExternalEventList___getslice__(self, *args)
    def __setslice__(self, *args): return _PyDynamics.ExternalEventList___setslice__(self, *args)
    def __delslice__(self, *args): return _PyDynamics.ExternalEventList___delslice__(self, *args)
    def __delitem__(self, *args): return _PyDynamics.ExternalEventList___delitem__(self, *args)
    def __getitem__(self, *args): return _PyDynamics.ExternalEventList___getitem__(self, *args)
    def __setitem__(self, *args): return _PyDynamics.ExternalEventList___setitem__(self, *args)
    def append(self, *args): return _PyDynamics.ExternalEventList_append(self, *args)
    def empty(self): return _PyDynamics.ExternalEventList_empty(self)
    def size(self): return _PyDynamics.ExternalEventList_size(self)
    def clear(self): return _PyDynamics.ExternalEventList_clear(self)
    def swap(self, *args): return _PyDynamics.ExternalEventList_swap(self, *args)
    def get_allocator(self): return _PyDynamics.ExternalEventList_get_allocator(self)
    def begin(self): return _PyDynamics.ExternalEventList_begin(self)
    def end(self): return _PyDynamics.ExternalEventList_end(self)
    def rbegin(self): return _PyDynamics.ExternalEventList_rbegin(self)
    def rend(self): return _PyDynamics.ExternalEventList_rend(self)
    def pop_back(self): return _PyDynamics.ExternalEventList_pop_back(self)
    def erase(self, *args): return _PyDynamics.ExternalEventList_erase(self, *args)
    def __init__(self, *args): 
        this = _PyDynamics.new_ExternalEventList(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _PyDynamics.ExternalEventList_push_back(self, *args)
    def front(self): return _PyDynamics.ExternalEventList_front(self)
    def back(self): return _PyDynamics.ExternalEventList_back(self)
    def assign(self, *args): return _PyDynamics.ExternalEventList_assign(self, *args)
    def resize(self, *args): return _PyDynamics.ExternalEventList_resize(self, *args)
    def insert(self, *args): return _PyDynamics.ExternalEventList_insert(self, *args)
    def reserve(self, *args): return _PyDynamics.ExternalEventList_reserve(self, *args)
    def capacity(self): return _PyDynamics.ExternalEventList_capacity(self)
    __swig_destroy__ = _PyDynamics.delete_ExternalEventList
    __del__ = lambda self : None;
ExternalEventList_swigregister = _PyDynamics.ExternalEventList_swigregister
ExternalEventList_swigregister(ExternalEventList)

class VectorValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VectorValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VectorValue, name)
    __repr__ = _swig_repr
    def iterator(self): return _PyDynamics.VectorValue_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _PyDynamics.VectorValue___nonzero__(self)
    def __bool__(self): return _PyDynamics.VectorValue___bool__(self)
    def __len__(self): return _PyDynamics.VectorValue___len__(self)
    def pop(self): return _PyDynamics.VectorValue_pop(self)
    def __getslice__(self, *args): return _PyDynamics.VectorValue___getslice__(self, *args)
    def __setslice__(self, *args): return _PyDynamics.VectorValue___setslice__(self, *args)
    def __delslice__(self, *args): return _PyDynamics.VectorValue___delslice__(self, *args)
    def __delitem__(self, *args): return _PyDynamics.VectorValue___delitem__(self, *args)
    def __getitem__(self, *args): return _PyDynamics.VectorValue___getitem__(self, *args)
    def __setitem__(self, *args): return _PyDynamics.VectorValue___setitem__(self, *args)
    def append(self, *args): return _PyDynamics.VectorValue_append(self, *args)
    def empty(self): return _PyDynamics.VectorValue_empty(self)
    def size(self): return _PyDynamics.VectorValue_size(self)
    def clear(self): return _PyDynamics.VectorValue_clear(self)
    def swap(self, *args): return _PyDynamics.VectorValue_swap(self, *args)
    def get_allocator(self): return _PyDynamics.VectorValue_get_allocator(self)
    def begin(self): return _PyDynamics.VectorValue_begin(self)
    def end(self): return _PyDynamics.VectorValue_end(self)
    def rbegin(self): return _PyDynamics.VectorValue_rbegin(self)
    def rend(self): return _PyDynamics.VectorValue_rend(self)
    def pop_back(self): return _PyDynamics.VectorValue_pop_back(self)
    def erase(self, *args): return _PyDynamics.VectorValue_erase(self, *args)
    def __init__(self, *args): 
        this = _PyDynamics.new_VectorValue(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _PyDynamics.VectorValue_push_back(self, *args)
    def front(self): return _PyDynamics.VectorValue_front(self)
    def back(self): return _PyDynamics.VectorValue_back(self)
    def assign(self, *args): return _PyDynamics.VectorValue_assign(self, *args)
    def resize(self, *args): return _PyDynamics.VectorValue_resize(self, *args)
    def insert(self, *args): return _PyDynamics.VectorValue_insert(self, *args)
    def reserve(self, *args): return _PyDynamics.VectorValue_reserve(self, *args)
    def capacity(self): return _PyDynamics.VectorValue_capacity(self)
    __swig_destroy__ = _PyDynamics.delete_VectorValue
    __del__ = lambda self : None;
VectorValue_swigregister = _PyDynamics.VectorValue_swigregister
VectorValue_swigregister(VectorValue)

class MapValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MapValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MapValue, name)
    __repr__ = _swig_repr
    def iterator(self): return _PyDynamics.MapValue_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _PyDynamics.MapValue___nonzero__(self)
    def __bool__(self): return _PyDynamics.MapValue___bool__(self)
    def __len__(self): return _PyDynamics.MapValue___len__(self)
    def __iter__(self): return self.key_iterator()
    def iterkeys(self): return self.key_iterator()
    def itervalues(self): return self.value_iterator()
    def iteritems(self): return self.iterator()
    def __getitem__(self, *args): return _PyDynamics.MapValue___getitem__(self, *args)
    def __delitem__(self, *args): return _PyDynamics.MapValue___delitem__(self, *args)
    def has_key(self, *args): return _PyDynamics.MapValue_has_key(self, *args)
    def keys(self): return _PyDynamics.MapValue_keys(self)
    def values(self): return _PyDynamics.MapValue_values(self)
    def items(self): return _PyDynamics.MapValue_items(self)
    def __contains__(self, *args): return _PyDynamics.MapValue___contains__(self, *args)
    def key_iterator(self): return _PyDynamics.MapValue_key_iterator(self)
    def value_iterator(self): return _PyDynamics.MapValue_value_iterator(self)
    def __setitem__(self, *args): return _PyDynamics.MapValue___setitem__(self, *args)
    def asdict(self): return _PyDynamics.MapValue_asdict(self)
    def __init__(self, *args): 
        this = _PyDynamics.new_MapValue(*args)
        try: self.this.append(this)
        except: self.this = this
    def empty(self): return _PyDynamics.MapValue_empty(self)
    def size(self): return _PyDynamics.MapValue_size(self)
    def clear(self): return _PyDynamics.MapValue_clear(self)
    def swap(self, *args): return _PyDynamics.MapValue_swap(self, *args)
    def get_allocator(self): return _PyDynamics.MapValue_get_allocator(self)
    def begin(self): return _PyDynamics.MapValue_begin(self)
    def end(self): return _PyDynamics.MapValue_end(self)
    def rbegin(self): return _PyDynamics.MapValue_rbegin(self)
    def rend(self): return _PyDynamics.MapValue_rend(self)
    def count(self, *args): return _PyDynamics.MapValue_count(self, *args)
    def erase(self, *args): return _PyDynamics.MapValue_erase(self, *args)
    def find(self, *args): return _PyDynamics.MapValue_find(self, *args)
    def lower_bound(self, *args): return _PyDynamics.MapValue_lower_bound(self, *args)
    def upper_bound(self, *args): return _PyDynamics.MapValue_upper_bound(self, *args)
    __swig_destroy__ = _PyDynamics.delete_MapValue
    __del__ = lambda self : None;
MapValue_swigregister = _PyDynamics.MapValue_swigregister
MapValue_swigregister(MapValue)

class DynamicsInit(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DynamicsInit, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DynamicsInit, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_DynamicsInit(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_DynamicsInit
    __del__ = lambda self : None;
    def model(self): return _PyDynamics.DynamicsInit_model(self)
    def packageid(self): return _PyDynamics.DynamicsInit_packageid(self)
DynamicsInit_swigregister = _PyDynamics.DynamicsInit_swigregister
DynamicsInit_swigregister(DynamicsInit)

class Dynamics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dynamics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dynamics, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_Dynamics(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_Dynamics
    __del__ = lambda self : None;
    def init(self, *args): return _PyDynamics.Dynamics_init(self, *args)
    def output(self, *args): return _PyDynamics.Dynamics_output(self, *args)
    def timeAdvance(self): return _PyDynamics.Dynamics_timeAdvance(self)
    def internalTransition(self, *args): return _PyDynamics.Dynamics_internalTransition(self, *args)
    def externalTransition(self, *args): return _PyDynamics.Dynamics_externalTransition(self, *args)
    def confluentTransitions(self, *args): return _PyDynamics.Dynamics_confluentTransitions(self, *args)
    def observation(self, *args): return _PyDynamics.Dynamics_observation(self, *args)
    def finish(self): return _PyDynamics.Dynamics_finish(self)
    def isExecutive(self): return _PyDynamics.Dynamics_isExecutive(self)
    def isWrapper(self): return _PyDynamics.Dynamics_isWrapper(self)
    def getModel(self): return _PyDynamics.Dynamics_getModel(self)
    def getModelName(self): return _PyDynamics.Dynamics_getModelName(self)
    def buildDouble(self, *args): return _PyDynamics.Dynamics_buildDouble(self, *args)
    def buildInteger(self, *args): return _PyDynamics.Dynamics_buildInteger(self, *args)
    def buildBoolean(self, *args): return _PyDynamics.Dynamics_buildBoolean(self, *args)
    def buildString(self, *args): return _PyDynamics.Dynamics_buildString(self, *args)
    def noEvent(self): return _PyDynamics.Dynamics_noEvent(self)
    def buildEvent(self, *args): return _PyDynamics.Dynamics_buildEvent(self, *args)
    def buildEventWithADouble(self, *args): return _PyDynamics.Dynamics_buildEventWithADouble(self, *args)
    def buildEventWithAInteger(self, *args): return _PyDynamics.Dynamics_buildEventWithAInteger(self, *args)
    def buildEventWithABoolean(self, *args): return _PyDynamics.Dynamics_buildEventWithABoolean(self, *args)
    def buildEventWithAString(self, *args): return _PyDynamics.Dynamics_buildEventWithAString(self, *args)
    def getPackageDir(self): return _PyDynamics.Dynamics_getPackageDir(self)
    def getPackageSimulatorDir(self): return _PyDynamics.Dynamics_getPackageSimulatorDir(self)
    def getPackageSrcDir(self): return _PyDynamics.Dynamics_getPackageSrcDir(self)
    def getPackageDataDir(self): return _PyDynamics.Dynamics_getPackageDataDir(self)
    def getPackageDocDir(self): return _PyDynamics.Dynamics_getPackageDocDir(self)
    def getPackageExpDir(self): return _PyDynamics.Dynamics_getPackageExpDir(self)
    def getPackageFile(self, *args): return _PyDynamics.Dynamics_getPackageFile(self, *args)
    def getPackageLibFile(self, *args): return _PyDynamics.Dynamics_getPackageLibFile(self, *args)
    def getPackageSrcFile(self, *args): return _PyDynamics.Dynamics_getPackageSrcFile(self, *args)
    def getPackageDataFile(self, *args): return _PyDynamics.Dynamics_getPackageDataFile(self, *args)
    def getPackageDocFile(self, *args): return _PyDynamics.Dynamics_getPackageDocFile(self, *args)
    def getPackageExpFile(self, *args): return _PyDynamics.Dynamics_getPackageExpFile(self, *args)
    def packageid(self): return _PyDynamics.Dynamics_packageid(self)
Dynamics_swigregister = _PyDynamics.Dynamics_swigregister
Dynamics_swigregister(Dynamics)

VLE_VALUE_VALUE_HPP = _PyDynamics.VLE_VALUE_VALUE_HPP
class Value(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Value, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Value, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["allocated"] = _PyDynamics.Value_allocated_set
    __swig_getmethods__["allocated"] = _PyDynamics.Value_allocated_get
    if _newclass:allocated = _swig_property(_PyDynamics.Value_allocated_get, _PyDynamics.Value_allocated_set)
    __swig_setmethods__["deallocated"] = _PyDynamics.Value_deallocated_set
    __swig_getmethods__["deallocated"] = _PyDynamics.Value_deallocated_get
    if _newclass:deallocated = _swig_property(_PyDynamics.Value_deallocated_get, _PyDynamics.Value_deallocated_set)
    BOOLEAN = _PyDynamics.Value_BOOLEAN
    INTEGER = _PyDynamics.Value_INTEGER
    DOUBLE = _PyDynamics.Value_DOUBLE
    STRING = _PyDynamics.Value_STRING
    SET = _PyDynamics.Value_SET
    MAP = _PyDynamics.Value_MAP
    TUPLE = _PyDynamics.Value_TUPLE
    TABLE = _PyDynamics.Value_TABLE
    XMLTYPE = _PyDynamics.Value_XMLTYPE
    NIL = _PyDynamics.Value_NIL
    MATRIX = _PyDynamics.Value_MATRIX
    __swig_destroy__ = _PyDynamics.delete_Value
    __del__ = lambda self : None;
    def clone(self): return _PyDynamics.Value_clone(self)
    def writeFile(self, *args): return _PyDynamics.Value_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.Value_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.Value_writeXml(self, *args)
    def getType(self): return _PyDynamics.Value_getType(self)
    def writeToFile(self): return _PyDynamics.Value_writeToFile(self)
    def writeToString(self): return _PyDynamics.Value_writeToString(self)
    def writeToXml(self): return _PyDynamics.Value_writeToXml(self)
    def isInteger(self): return _PyDynamics.Value_isInteger(self)
    def isBoolean(self): return _PyDynamics.Value_isBoolean(self)
    def isDouble(self): return _PyDynamics.Value_isDouble(self)
    def isString(self): return _PyDynamics.Value_isString(self)
    def isSet(self): return _PyDynamics.Value_isSet(self)
    def isMap(self): return _PyDynamics.Value_isMap(self)
    def isTuple(self): return _PyDynamics.Value_isTuple(self)
    def isTable(self): return _PyDynamics.Value_isTable(self)
    def isXml(self): return _PyDynamics.Value_isXml(self)
    def isNull(self): return _PyDynamics.Value_isNull(self)
    def isMatrix(self): return _PyDynamics.Value_isMatrix(self)
    __swig_getmethods__["isComposite"] = lambda x: _PyDynamics.Value_isComposite
    if _newclass:isComposite = staticmethod(_PyDynamics.Value_isComposite)
    def toBoolean(self, *args): return _PyDynamics.Value_toBoolean(self, *args)
    def toInteger(self, *args): return _PyDynamics.Value_toInteger(self, *args)
    def toDouble(self, *args): return _PyDynamics.Value_toDouble(self, *args)
    def toString(self, *args): return _PyDynamics.Value_toString(self, *args)
    def toSet(self, *args): return _PyDynamics.Value_toSet(self, *args)
    def toMap(self, *args): return _PyDynamics.Value_toMap(self, *args)
    def toTuple(self, *args): return _PyDynamics.Value_toTuple(self, *args)
    def toTable(self, *args): return _PyDynamics.Value_toTable(self, *args)
    def toXml(self, *args): return _PyDynamics.Value_toXml(self, *args)
    def toNull(self, *args): return _PyDynamics.Value_toNull(self, *args)
    def toMatrix(self, *args): return _PyDynamics.Value_toMatrix(self, *args)
Value_swigregister = _PyDynamics.Value_swigregister
Value_swigregister(Value)
cvar = _PyDynamics.cvar

def Value_isComposite(*args):
  return _PyDynamics.Value_isComposite(*args)
Value_isComposite = _PyDynamics.Value_isComposite

class IsComposite(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsComposite, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsComposite, name)
    __repr__ = _swig_repr
    def __call__(self, *args): return _PyDynamics.IsComposite___call__(self, *args)
    def __init__(self): 
        this = _PyDynamics.new_IsComposite()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_IsComposite
    __del__ = lambda self : None;
IsComposite_swigregister = _PyDynamics.IsComposite_swigregister
IsComposite_swigregister(IsComposite)

def reference(*args):
  return _PyDynamics.reference(*args)
reference = _PyDynamics.reference

class CloneValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CloneValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CloneValue, name)
    __repr__ = _swig_repr
    def __call__(self, *args): return _PyDynamics.CloneValue___call__(self, *args)
    def __init__(self): 
        this = _PyDynamics.new_CloneValue()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_CloneValue
    __del__ = lambda self : None;
CloneValue_swigregister = _PyDynamics.CloneValue_swigregister
CloneValue_swigregister(CloneValue)

VLE_VALUE_DOUBLE_HPP = _PyDynamics.VLE_VALUE_DOUBLE_HPP
class Double(Value):
    __swig_setmethods__ = {}
    for _s in [Value]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Double, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Double, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_Double(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_Double
    __del__ = lambda self : None;
    __swig_getmethods__["create"] = lambda x: _PyDynamics.Double_create
    if _newclass:create = staticmethod(_PyDynamics.Double_create)
    def clone(self): return _PyDynamics.Double_clone(self)
    def getType(self): return _PyDynamics.Double_getType(self)
    def writeFile(self, *args): return _PyDynamics.Double_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.Double_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.Double_writeXml(self, *args)
    def value(self, *args): return _PyDynamics.Double_value(self, *args)
    def set(self, *args): return _PyDynamics.Double_set(self, *args)
Double_swigregister = _PyDynamics.Double_swigregister
Double_swigregister(Double)

def Double_create(value = 0.0):
  return _PyDynamics.Double_create(value)
Double_create = _PyDynamics.Double_create

VLE_VALUE_INTEGER_HPP = _PyDynamics.VLE_VALUE_INTEGER_HPP
class Integer(Value):
    __swig_setmethods__ = {}
    for _s in [Value]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Integer, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Integer, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_Integer(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_Integer
    __del__ = lambda self : None;
    __swig_getmethods__["create"] = lambda x: _PyDynamics.Integer_create
    if _newclass:create = staticmethod(_PyDynamics.Integer_create)
    def clone(self): return _PyDynamics.Integer_clone(self)
    def getType(self): return _PyDynamics.Integer_getType(self)
    def writeFile(self, *args): return _PyDynamics.Integer_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.Integer_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.Integer_writeXml(self, *args)
    def value(self, *args): return _PyDynamics.Integer_value(self, *args)
    def set(self, *args): return _PyDynamics.Integer_set(self, *args)
Integer_swigregister = _PyDynamics.Integer_swigregister
Integer_swigregister(Integer)

def toDoubleValue(*args):
  return _PyDynamics.toDoubleValue(*args)
toDoubleValue = _PyDynamics.toDoubleValue

def toDouble(*args):
  return _PyDynamics.toDouble(*args)
toDouble = _PyDynamics.toDouble

def Integer_create(value = 0):
  return _PyDynamics.Integer_create(value)
Integer_create = _PyDynamics.Integer_create

VLE_VALUE_BOOLEAN_HPP = _PyDynamics.VLE_VALUE_BOOLEAN_HPP
class Boolean(Value):
    __swig_setmethods__ = {}
    for _s in [Value]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Boolean, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Boolean, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_Boolean(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_Boolean
    __del__ = lambda self : None;
    __swig_getmethods__["create"] = lambda x: _PyDynamics.Boolean_create
    if _newclass:create = staticmethod(_PyDynamics.Boolean_create)
    def clone(self): return _PyDynamics.Boolean_clone(self)
    def getType(self): return _PyDynamics.Boolean_getType(self)
    def writeFile(self, *args): return _PyDynamics.Boolean_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.Boolean_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.Boolean_writeXml(self, *args)
    def value(self, *args): return _PyDynamics.Boolean_value(self, *args)
    def set(self, *args): return _PyDynamics.Boolean_set(self, *args)
Boolean_swigregister = _PyDynamics.Boolean_swigregister
Boolean_swigregister(Boolean)

def toIntegerValue(*args):
  return _PyDynamics.toIntegerValue(*args)
toIntegerValue = _PyDynamics.toIntegerValue

def toInteger(*args):
  return _PyDynamics.toInteger(*args)
toInteger = _PyDynamics.toInteger

def Boolean_create(value = False):
  return _PyDynamics.Boolean_create(value)
Boolean_create = _PyDynamics.Boolean_create

VLE_VALUE_STRING_HPP = _PyDynamics.VLE_VALUE_STRING_HPP
class String(Value):
    __swig_setmethods__ = {}
    for _s in [Value]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, String, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, String, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_String(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_String
    __del__ = lambda self : None;
    __swig_getmethods__["create"] = lambda x: _PyDynamics.String_create
    if _newclass:create = staticmethod(_PyDynamics.String_create)
    def clone(self): return _PyDynamics.String_clone(self)
    def getType(self): return _PyDynamics.String_getType(self)
    def writeFile(self, *args): return _PyDynamics.String_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.String_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.String_writeXml(self, *args)
    def value(self, *args): return _PyDynamics.String_value(self, *args)
    def set(self, *args): return _PyDynamics.String_set(self, *args)
String_swigregister = _PyDynamics.String_swigregister
String_swigregister(String)

def toBooleanValue(*args):
  return _PyDynamics.toBooleanValue(*args)
toBooleanValue = _PyDynamics.toBooleanValue

def toBoolean(*args):
  return _PyDynamics.toBoolean(*args)
toBoolean = _PyDynamics.toBoolean

def String_create(*args):
  return _PyDynamics.String_create(*args)
String_create = _PyDynamics.String_create

VLE_VALUE_MAP_HPP = _PyDynamics.VLE_VALUE_MAP_HPP
class Map(Value):
    __swig_setmethods__ = {}
    for _s in [Value]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Map, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Map, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_Map(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_Map
    __del__ = lambda self : None;
    __swig_getmethods__["create"] = lambda x: _PyDynamics.Map_create
    if _newclass:create = staticmethod(_PyDynamics.Map_create)
    def clone(self): return _PyDynamics.Map_clone(self)
    def getType(self): return _PyDynamics.Map_getType(self)
    def writeFile(self, *args): return _PyDynamics.Map_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.Map_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.Map_writeXml(self, *args)
    def add(self, *args): return _PyDynamics.Map_add(self, *args)
    def set(self, *args): return _PyDynamics.Map_set(self, *args)
    def exist(self, *args): return _PyDynamics.Map_exist(self, *args)
    def get(self, *args): return _PyDynamics.Map_get(self, *args)
    def give(self, *args): return _PyDynamics.Map_give(self, *args)
    def value(self, *args): return _PyDynamics.Map_value(self, *args)
    def clear(self): return _PyDynamics.Map_clear(self)
    def empty(self): return _PyDynamics.Map_empty(self)
    def size(self): return _PyDynamics.Map_size(self)
    def begin(self, *args): return _PyDynamics.Map_begin(self, *args)
    def end(self, *args): return _PyDynamics.Map_end(self, *args)
    def find(self, *args): return _PyDynamics.Map_find(self, *args)
    def addNull(self, *args): return _PyDynamics.Map_addNull(self, *args)
    def getString(self, *args): return _PyDynamics.Map_getString(self, *args)
    def addString(self, *args): return _PyDynamics.Map_addString(self, *args)
    def getBoolean(self, *args): return _PyDynamics.Map_getBoolean(self, *args)
    def addBoolean(self, *args): return _PyDynamics.Map_addBoolean(self, *args)
    def getInt(self, *args): return _PyDynamics.Map_getInt(self, *args)
    def addInt(self, *args): return _PyDynamics.Map_addInt(self, *args)
    def getDouble(self, *args): return _PyDynamics.Map_getDouble(self, *args)
    def addDouble(self, *args): return _PyDynamics.Map_addDouble(self, *args)
    def getXml(self, *args): return _PyDynamics.Map_getXml(self, *args)
    def addXml(self, *args): return _PyDynamics.Map_addXml(self, *args)
    def getTable(self, *args): return _PyDynamics.Map_getTable(self, *args)
    def addTable(self, *args): return _PyDynamics.Map_addTable(self, *args)
    def getTuple(self, *args): return _PyDynamics.Map_getTuple(self, *args)
    def addTuple(self, *args): return _PyDynamics.Map_addTuple(self, *args)
    def addMap(self, *args): return _PyDynamics.Map_addMap(self, *args)
    def addSet(self, *args): return _PyDynamics.Map_addSet(self, *args)
    def addMatrix(self, *args): return _PyDynamics.Map_addMatrix(self, *args)
    def getMap(self, *args): return _PyDynamics.Map_getMap(self, *args)
    def getSet(self, *args): return _PyDynamics.Map_getSet(self, *args)
    def getMatrix(self, *args): return _PyDynamics.Map_getMatrix(self, *args)
Map_swigregister = _PyDynamics.Map_swigregister
Map_swigregister(Map)

def toStringValue(*args):
  return _PyDynamics.toStringValue(*args)
toStringValue = _PyDynamics.toStringValue

def toString(*args):
  return _PyDynamics.toString(*args)
toString = _PyDynamics.toString

def Map_create():
  return _PyDynamics.Map_create()
Map_create = _PyDynamics.Map_create

VLE_VALUE_SET_HPP = _PyDynamics.VLE_VALUE_SET_HPP
class Set(Value):
    __swig_setmethods__ = {}
    for _s in [Value]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Set, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Set, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_Set(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_Set
    __del__ = lambda self : None;
    __swig_getmethods__["create"] = lambda x: _PyDynamics.Set_create
    if _newclass:create = staticmethod(_PyDynamics.Set_create)
    def clone(self): return _PyDynamics.Set_clone(self)
    def getType(self): return _PyDynamics.Set_getType(self)
    def writeFile(self, *args): return _PyDynamics.Set_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.Set_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.Set_writeXml(self, *args)
    def value(self, *args): return _PyDynamics.Set_value(self, *args)
    def begin(self, *args): return _PyDynamics.Set_begin(self, *args)
    def end(self, *args): return _PyDynamics.Set_end(self, *args)
    def set(self, *args): return _PyDynamics.Set_set(self, *args)
    def get(self, *args): return _PyDynamics.Set_get(self, *args)
    def give(self, *args): return _PyDynamics.Set_give(self, *args)
    def size(self): return _PyDynamics.Set_size(self)
    def empty(self): return _PyDynamics.Set_empty(self)
    def clear(self): return _PyDynamics.Set_clear(self)
    def add(self, *args): return _PyDynamics.Set_add(self, *args)
    def addNull(self): return _PyDynamics.Set_addNull(self)
    def addBoolean(self, *args): return _PyDynamics.Set_addBoolean(self, *args)
    def getBoolean(self, *args): return _PyDynamics.Set_getBoolean(self, *args)
    def addDouble(self, *args): return _PyDynamics.Set_addDouble(self, *args)
    def getDouble(self, *args): return _PyDynamics.Set_getDouble(self, *args)
    def addInt(self, *args): return _PyDynamics.Set_addInt(self, *args)
    def getInt(self, *args): return _PyDynamics.Set_getInt(self, *args)
    def addString(self, *args): return _PyDynamics.Set_addString(self, *args)
    def getString(self, *args): return _PyDynamics.Set_getString(self, *args)
    def addXml(self, *args): return _PyDynamics.Set_addXml(self, *args)
    def getXml(self, *args): return _PyDynamics.Set_getXml(self, *args)
    def addTable(self, width = 0, height = 0): return _PyDynamics.Set_addTable(self, width, height)
    def getTable(self, *args): return _PyDynamics.Set_getTable(self, *args)
    def addTuple(self, width = 0, value = 0.0): return _PyDynamics.Set_addTuple(self, width, value)
    def getTuple(self, *args): return _PyDynamics.Set_getTuple(self, *args)
    def addSet(self): return _PyDynamics.Set_addSet(self)
    def addMap(self): return _PyDynamics.Set_addMap(self)
    def addMatrix(self): return _PyDynamics.Set_addMatrix(self)
    def getSet(self, *args): return _PyDynamics.Set_getSet(self, *args)
    def getMap(self, *args): return _PyDynamics.Set_getMap(self, *args)
    def getMatrix(self, *args): return _PyDynamics.Set_getMatrix(self, *args)
Set_swigregister = _PyDynamics.Set_swigregister
Set_swigregister(Set)

def toMapValue(*args):
  return _PyDynamics.toMapValue(*args)
toMapValue = _PyDynamics.toMapValue

def toMap(*args):
  return _PyDynamics.toMap(*args)
toMap = _PyDynamics.toMap

def Set_create(size = 0):
  return _PyDynamics.Set_create(size)
Set_create = _PyDynamics.Set_create

VLE_VALUE_NULL_HPP = _PyDynamics.VLE_VALUE_NULL_HPP
class Null(Value):
    __swig_setmethods__ = {}
    for _s in [Value]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Null, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, Null, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_Null(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_Null
    __del__ = lambda self : None;
    __swig_getmethods__["create"] = lambda x: _PyDynamics.Null_create
    if _newclass:create = staticmethod(_PyDynamics.Null_create)
    def clone(self): return _PyDynamics.Null_clone(self)
    def getType(self): return _PyDynamics.Null_getType(self)
    def writeFile(self, *args): return _PyDynamics.Null_writeFile(self, *args)
    def writeString(self, *args): return _PyDynamics.Null_writeString(self, *args)
    def writeXml(self, *args): return _PyDynamics.Null_writeXml(self, *args)
Null_swigregister = _PyDynamics.Null_swigregister
Null_swigregister(Null)

def toSetValue(*args):
  return _PyDynamics.toSetValue(*args)
toSetValue = _PyDynamics.toSetValue

def toSet(*args):
  return _PyDynamics.toSet(*args)
toSet = _PyDynamics.toSet

def Null_create():
  return _PyDynamics.Null_create()
Null_create = _PyDynamics.Null_create

class IsNullValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IsNullValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IsNullValue, name)
    __repr__ = _swig_repr
    def __call__(self, *args): return _PyDynamics.IsNullValue___call__(self, *args)
    def __init__(self): 
        this = _PyDynamics.new_IsNullValue()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_IsNullValue
    __del__ = lambda self : None;
IsNullValue_swigregister = _PyDynamics.IsNullValue_swigregister
IsNullValue_swigregister(IsNullValue)


def isNan(*args):
  return _PyDynamics.isNan(*args)
isNan = _PyDynamics.isNan

def isInfinity(*args):
  return _PyDynamics.isInfinity(*args)
isInfinity = _PyDynamics.isInfinity

def isPositiveInfinity(*args):
  return _PyDynamics.isPositiveInfinity(*args)
isPositiveInfinity = _PyDynamics.isPositiveInfinity

def isNegativeInfinity(*args):
  return _PyDynamics.isNegativeInfinity(*args)
isNegativeInfinity = _PyDynamics.isNegativeInfinity

def convertTimeToString(*args):
  return _PyDynamics.convertTimeToString(*args)
convertTimeToString = _PyDynamics.convertTimeToString
class ExternalEvent(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExternalEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ExternalEvent, name)
    __repr__ = _swig_repr
    __swig_setmethods__["allocated"] = _PyDynamics.ExternalEvent_allocated_set
    __swig_getmethods__["allocated"] = _PyDynamics.ExternalEvent_allocated_get
    if _newclass:allocated = _swig_property(_PyDynamics.ExternalEvent_allocated_get, _PyDynamics.ExternalEvent_allocated_set)
    __swig_setmethods__["deallocated"] = _PyDynamics.ExternalEvent_deallocated_set
    __swig_getmethods__["deallocated"] = _PyDynamics.ExternalEvent_deallocated_get
    if _newclass:deallocated = _swig_property(_PyDynamics.ExternalEvent_deallocated_get, _PyDynamics.ExternalEvent_deallocated_set)
    def __init__(self, *args): 
        this = _PyDynamics.new_ExternalEvent(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_ExternalEvent
    __del__ = lambda self : None;
    def getPortName(self): return _PyDynamics.ExternalEvent_getPortName(self)
    def getTarget(self): return _PyDynamics.ExternalEvent_getTarget(self)
    def onPort(self, *args): return _PyDynamics.ExternalEvent_onPort(self, *args)
    def putAttributes(self, *args): return _PyDynamics.ExternalEvent_putAttributes(self, *args)
    def putAttribute(self, *args): return _PyDynamics.ExternalEvent_putAttribute(self, *args)
    def existAttributeValue(self, *args): return _PyDynamics.ExternalEvent_existAttributeValue(self, *args)
    def getAttributeValue(self, *args): return _PyDynamics.ExternalEvent_getAttributeValue(self, *args)
    def getDoubleAttributeValue(self, *args): return _PyDynamics.ExternalEvent_getDoubleAttributeValue(self, *args)
    def getIntegerAttributeValue(self, *args): return _PyDynamics.ExternalEvent_getIntegerAttributeValue(self, *args)
    def getBooleanAttributeValue(self, *args): return _PyDynamics.ExternalEvent_getBooleanAttributeValue(self, *args)
    def getStringAttributeValue(self, *args): return _PyDynamics.ExternalEvent_getStringAttributeValue(self, *args)
    def getSetAttributeValue(self, *args): return _PyDynamics.ExternalEvent_getSetAttributeValue(self, *args)
    def getMapAttributeValue(self, *args): return _PyDynamics.ExternalEvent_getMapAttributeValue(self, *args)
    def getAttributes(self, *args): return _PyDynamics.ExternalEvent_getAttributes(self, *args)
    def haveAttributes(self): return _PyDynamics.ExternalEvent_haveAttributes(self)
    def attributes(self, *args): return _PyDynamics.ExternalEvent_attributes(self, *args)
ExternalEvent_swigregister = _PyDynamics.ExternalEvent_swigregister
ExternalEvent_swigregister(ExternalEvent)

def toNullValue(*args):
  return _PyDynamics.toNullValue(*args)
toNullValue = _PyDynamics.toNullValue
infinity = cvar.infinity
negativeInfinity = cvar.negativeInfinity


def __lshift__(*args):
  return _PyDynamics.__lshift__(*args)
__lshift__ = _PyDynamics.__lshift__
VLE_DEVS_OBSERVATION_EVENT_HPP = _PyDynamics.VLE_DEVS_OBSERVATION_EVENT_HPP
class ObservationEvent(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ObservationEvent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ObservationEvent, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_ObservationEvent(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _PyDynamics.delete_ObservationEvent
    __del__ = lambda self : None;
    def getViewName(self): return _PyDynamics.ObservationEvent_getViewName(self)
    def getPortName(self): return _PyDynamics.ObservationEvent_getPortName(self)
    def onPort(self, *args): return _PyDynamics.ObservationEvent_onPort(self, *args)
    def getTime(self): return _PyDynamics.ObservationEvent_getTime(self)
    def putAttributes(self, *args): return _PyDynamics.ObservationEvent_putAttributes(self, *args)
    def putAttribute(self, *args): return _PyDynamics.ObservationEvent_putAttribute(self, *args)
    def existAttributeValue(self, *args): return _PyDynamics.ObservationEvent_existAttributeValue(self, *args)
    def getAttributeValue(self, *args): return _PyDynamics.ObservationEvent_getAttributeValue(self, *args)
    def getDoubleAttributeValue(self, *args): return _PyDynamics.ObservationEvent_getDoubleAttributeValue(self, *args)
    def getIntegerAttributeValue(self, *args): return _PyDynamics.ObservationEvent_getIntegerAttributeValue(self, *args)
    def getBooleanAttributeValue(self, *args): return _PyDynamics.ObservationEvent_getBooleanAttributeValue(self, *args)
    def getStringAttributeValue(self, *args): return _PyDynamics.ObservationEvent_getStringAttributeValue(self, *args)
    def getSetAttributeValue(self, *args): return _PyDynamics.ObservationEvent_getSetAttributeValue(self, *args)
    def getMapAttributeValue(self, *args): return _PyDynamics.ObservationEvent_getMapAttributeValue(self, *args)
    def getAttributes(self, *args): return _PyDynamics.ObservationEvent_getAttributes(self, *args)
    def haveAttributes(self): return _PyDynamics.ObservationEvent_haveAttributes(self)
    def attributes(self, *args): return _PyDynamics.ObservationEvent_attributes(self, *args)
ObservationEvent_swigregister = _PyDynamics.ObservationEvent_swigregister
ObservationEvent_swigregister(ObservationEvent)

class AtomicModel(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AtomicModel, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AtomicModel, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _PyDynamics.new_AtomicModel(*args)
        try: self.this.append(this)
        except: self.this = this
    def clone(self): return _PyDynamics.AtomicModel_clone(self)
    __swig_destroy__ = _PyDynamics.delete_AtomicModel
    __del__ = lambda self : None;
    def isAtomic(self): return _PyDynamics.AtomicModel_isAtomic(self)
    def conditions(self): return _PyDynamics.AtomicModel_conditions(self)
    def dynamics(self): return _PyDynamics.AtomicModel_dynamics(self)
    def observables(self): return _PyDynamics.AtomicModel_observables(self)
    def setConditions(self, *args): return _PyDynamics.AtomicModel_setConditions(self, *args)
    def addCondition(self, *args): return _PyDynamics.AtomicModel_addCondition(self, *args)
    def delCondition(self, *args): return _PyDynamics.AtomicModel_delCondition(self, *args)
    def setDynamics(self, *args): return _PyDynamics.AtomicModel_setDynamics(self, *args)
    def setObservables(self, *args): return _PyDynamics.AtomicModel_setObservables(self, *args)
    def findModel(self, *args): return _PyDynamics.AtomicModel_findModel(self, *args)
    def writeXML(self, *args): return _PyDynamics.AtomicModel_writeXML(self, *args)
    def write(self, *args): return _PyDynamics.AtomicModel_write(self, *args)
    def updateDynamics(self, *args): return _PyDynamics.AtomicModel_updateDynamics(self, *args)
    def purgeDynamics(self, *args): return _PyDynamics.AtomicModel_purgeDynamics(self, *args)
    def updateObservable(self, *args): return _PyDynamics.AtomicModel_updateObservable(self, *args)
    def purgeObservable(self, *args): return _PyDynamics.AtomicModel_purgeObservable(self, *args)
    def updateConditions(self, *args): return _PyDynamics.AtomicModel_updateConditions(self, *args)
    def purgeConditions(self, *args): return _PyDynamics.AtomicModel_purgeConditions(self, *args)
AtomicModel_swigregister = _PyDynamics.AtomicModel_swigregister
AtomicModel_swigregister(AtomicModel)

class PackageTable(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PackageTable, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PackageTable, name)
    __repr__ = _swig_repr
    def __init__(self): 
        this = _PyDynamics.new_PackageTable()
        try: self.this.append(this)
        except: self.this = this
    def get(self, *args): return _PyDynamics.PackageTable_get(self, *args)
    def remove(self, *args): return _PyDynamics.PackageTable_remove(self, *args)
    def begin(self): return _PyDynamics.PackageTable_begin(self)
    def end(self): return _PyDynamics.PackageTable_end(self)
    def size(self): return _PyDynamics.PackageTable_size(self)
    def empty(self): return _PyDynamics.PackageTable_empty(self)
    __swig_destroy__ = _PyDynamics.delete_PackageTable
    __del__ = lambda self : None;
PackageTable_swigregister = _PyDynamics.PackageTable_swigregister
PackageTable_swigregister(PackageTable)

VLE_MAJOR_VERSION = _PyDynamics.VLE_MAJOR_VERSION
VLE_MINOR_VERSION = _PyDynamics.VLE_MINOR_VERSION
VLE_PATCH_VERSION = _PyDynamics.VLE_PATCH_VERSION
VLE_EXTRA_VERSION = _PyDynamics.VLE_EXTRA_VERSION
VLE_VERSION = _PyDynamics.VLE_VERSION
VLE_ABI_VERSION = _PyDynamics.VLE_ABI_VERSION
VLE_NAME_COMPLETE = _PyDynamics.VLE_NAME_COMPLETE
VLE_LOCALE_NAME = _PyDynamics.VLE_LOCALE_NAME
VLE_SYSTEM_NAME = _PyDynamics.VLE_SYSTEM_NAME
VLE_SYSTEM_PROCESSOR = _PyDynamics.VLE_SYSTEM_PROCESSOR
VLE_PREFIX_DIR = _PyDynamics.VLE_PREFIX_DIR
VLE_LIBRARY_DIRS = _PyDynamics.VLE_LIBRARY_DIRS
VLE_SHARE_DIRS = _PyDynamics.VLE_SHARE_DIRS
class InitEventList(Map) : pass

# This file is compatible with both classic and new-style classes.


